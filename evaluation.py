import math
import numpy as np
from sklearn.metrics import classification_report
import collections


class ClusterEvaluation:
    '''
    groundtruthlabels and predicted_clusters should be two list, for example:
    groundtruthlabels = [0, 0, 1, 1], that means the 0th and 1th data is in cluster 0,
    and the 2th and 3th data is in cluster 1
    '''
    def __init__(self, groundtruthlabels, predicted_clusters):
        self.relations = {}
        self.groundtruthsets, self.assessableElemSet = self.createGroundTruthSets(groundtruthlabels)
        self.predictedsets = self.createPredictedSets(predicted_clusters)

    def createGroundTruthSets(self, labels):

        groundtruthsets= {}
        assessableElems = set()

        for i, c in enumerate(labels):
            assessableElems.add(i)
            groundtruthsets.setdefault(c, set()).add(i)

        return groundtruthsets, assessableElems

    def createPredictedSets(self, cs):

        predictedsets = {}
        for i, c in enumerate(cs):
            predictedsets.setdefault(c, set()).add(i)

        return predictedsets

    def b3precision(self, response_a, reference_a):
        return len(response_a.intersection(reference_a)) / float(len(response_a.intersection(self.assessableElemSet)))

    def b3recall(self, response_a, reference_a):
        return len(response_a.intersection(reference_a)) / float(len(reference_a))

    def b3TotalElementPrecision(self):
        totalPrecision = 0.0
        for c in self.predictedsets:
            for r in self.predictedsets[c]:
                totalPrecision += self.b3precision(self.predictedsets[c],
                                                   self.findCluster(r, self.groundtruthsets))

        return totalPrecision / float(len(self.assessableElemSet))

    def b3TotalElementRecall(self):
        totalRecall = 0.0
        for c in self.predictedsets:
            for r in self.predictedsets[c]:
                totalRecall += self.b3recall(self.predictedsets[c], self.findCluster(r, self.groundtruthsets))

        return totalRecall / float(len(self.assessableElemSet))

    def findCluster(self, a, setsDictionary):
        for c in setsDictionary:
            if a in setsDictionary[c]:
                return setsDictionary[c]

    def printEvaluation(self):

        recB3 = self.b3TotalElementRecall()
        precB3 = self.b3TotalElementPrecision()
        betasquare = math.pow(0.5, 2)
        if recB3 == 0.0 and precB3 == 0.0:
            F1B3 = 0.0
            F05B3 = 0.0
        else:
            betasquare = math.pow(0.5, 2)
            F1B3 = (2 * recB3 * precB3) / (recB3 + precB3)
            F05B3 = ((1+betasquare) * recB3 * precB3)/((betasquare*precB3)+recB3)

        m = {'F1': F1B3, 'F0.5': F05B3, 'precision': precB3, 'recall': recB3}
        return m

    def getF05(self):
        recB3 = self.b3TotalElementRecall()
        precB3 = self.b3TotalElementPrecision()
        betasquare = math.pow(0.5, 2)
        if recB3 == 0.0 and precB3 == 0.0:
            F05B3 = 0.0
        else:
            F05B3 = ((1+betasquare) * recB3 * precB3)/((betasquare*precB3)+recB3)
        return F05B3

    def getF1(self):
        recB3 = self.b3TotalElementRecall()
        precB3 = self.b3TotalElementPrecision()

        if recB3 == 0.0 and precB3 == 0.0:
            F1B3 = 0.0
        else:
            F1B3 = (2 * recB3 * precB3) / (recB3 + precB3)
        return F1B3
    

def standard_metric_result(args, gt, cluster_result, labellist):
    unseen_predict_label = []  
    cluster_truelabel_dict = collections.defaultdict(list) # {pred_id:[g_rel_name, ...]}
    cluster_id_dict = collections.defaultdict(list) # {pred_id: [样本id]}
    new_relation_dict = collections.defaultdict(int) # {样本id：预测关系id}

    for id in range(len(cluster_result)):
        cluster_truelabel_dict[cluster_result[id]].append(gt[id])  
        cluster_id_dict[cluster_result[id]].append(id)   

    for key in cluster_truelabel_dict: #对于每一类聚类结果
        new_relation = collections.Counter(cluster_truelabel_dict[key]).most_common(1)[0][0]  # 最多的关系名
        for i in cluster_id_dict[key]:
            new_relation_dict[str(i)] = labellist.index(new_relation)  

    for lunkuo_id in range(len(cluster_result)):
        unseen_predict_label.append(new_relation_dict[str(lunkuo_id)]) # 所有预测关系id
        
        
    unseen_label_id = [] # 真实关系id
    for label in gt:
        unseen_label_id.append(labellist.index(label))

    np.save('{}_{}_prediction.npy'.format(args.dataset, args.unseen_nums), np.array(unseen_predict_label))
    np.save('{}_{}_label.npy'.format(args.dataset, args.unseen_nums), np.array(unseen_label_id))
    metric_result = classification_report(unseen_label_id, unseen_predict_label, digits=5)

    return metric_result